# coding: utf-8

"""
    CLOUD API

     IONOS Enterprise-grade Infrastructure as a Service (IaaS) solutions can be managed through the Cloud API, in addition or as an alternative to the \"Data Center Designer\" (DCD) browser-based tool.    Both methods employ consistent concepts and features, deliver similar power and flexibility, and can be used to perform a multitude of management tasks, including adding servers, volumes, configuring networks, and so on.

    The version of the OpenAPI document: 6.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.lans import Lans
from openapi_client.models.loadbalancers import Loadbalancers
from openapi_client.models.nat_gateways import NatGateways
from openapi_client.models.network_load_balancers import NetworkLoadBalancers
from openapi_client.models.security_groups import SecurityGroups
from openapi_client.models.servers import Servers
from openapi_client.models.volumes import Volumes
from typing import Optional, Set
from typing_extensions import Self

class DatacenterEntities(BaseModel):
    """
    DatacenterEntities
    """ # noqa: E501
    servers: Optional[Servers] = None
    volumes: Optional[Volumes] = None
    loadbalancers: Optional[Loadbalancers] = None
    lans: Optional[Lans] = None
    networkloadbalancers: Optional[NetworkLoadBalancers] = None
    natgateways: Optional[NatGateways] = None
    securitygroups: Optional[SecurityGroups] = None
    __properties: ClassVar[List[str]] = ["servers", "volumes", "loadbalancers", "lans", "networkloadbalancers", "natgateways", "securitygroups"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of DatacenterEntities from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of servers
        if self.servers:
            _dict['servers'] = self.servers.to_dict()
        # override the default output from pydantic by calling `to_dict()` of volumes
        if self.volumes:
            _dict['volumes'] = self.volumes.to_dict()
        # override the default output from pydantic by calling `to_dict()` of loadbalancers
        if self.loadbalancers:
            _dict['loadbalancers'] = self.loadbalancers.to_dict()
        # override the default output from pydantic by calling `to_dict()` of lans
        if self.lans:
            _dict['lans'] = self.lans.to_dict()
        # override the default output from pydantic by calling `to_dict()` of networkloadbalancers
        if self.networkloadbalancers:
            _dict['networkloadbalancers'] = self.networkloadbalancers.to_dict()
        # override the default output from pydantic by calling `to_dict()` of natgateways
        if self.natgateways:
            _dict['natgateways'] = self.natgateways.to_dict()
        # override the default output from pydantic by calling `to_dict()` of securitygroups
        if self.securitygroups:
            _dict['securitygroups'] = self.securitygroups.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of DatacenterEntities from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "servers": Servers.from_dict(obj["servers"]) if obj.get("servers") is not None else None,
            "volumes": Volumes.from_dict(obj["volumes"]) if obj.get("volumes") is not None else None,
            "loadbalancers": Loadbalancers.from_dict(obj["loadbalancers"]) if obj.get("loadbalancers") is not None else None,
            "lans": Lans.from_dict(obj["lans"]) if obj.get("lans") is not None else None,
            "networkloadbalancers": NetworkLoadBalancers.from_dict(obj["networkloadbalancers"]) if obj.get("networkloadbalancers") is not None else None,
            "natgateways": NatGateways.from_dict(obj["natgateways"]) if obj.get("natgateways") is not None else None,
            "securitygroups": SecurityGroups.from_dict(obj["securitygroups"]) if obj.get("securitygroups") is not None else None
        })
        return _obj


